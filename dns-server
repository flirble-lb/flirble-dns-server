#!/usr/bin/env python
# Flirble DNS Server

import os, logging
log = logging.getLogger(os.path.basename(__file__))

import argparse, sys, traceback
import daemon, lockfile.pidlockfile
import FlirbleDNSServer as fdns

# Defaults for the command line options.
FOREGROUND = False
DEBUG = fdns.debug
LOGFILE = None
LOGLEVEL = "info"
PIDFILE = "/var/run/flirble-dns-server.pid"
ADDRESS = '::'
PORT = 8053
ZONES = "zones.json"
SERVERS = "servers.json"
GEODB = "/usr/local/share/GeoIP/GeoLite2-City.mmdb"

parser = argparse.ArgumentParser(description="Flirble DNS Server version %s." % fdns.version)
parser.add_argument("-f", "--foreground", default=FOREGROUND, action="store_true", help="Don't daemonize, stay in the foreground. [%s]" % str(FOREGROUND))
parser.add_argument("-d", "--debug", default=DEBUG, action="store_true", help="Print extra diagnostic data. Implies --foreground and --log-level=debug. [%s]" % str(DEBUG))
parser.add_argument("--log-file", metavar="filename", default=LOGFILE, help="File to send logging output to. [%s]" % "stderr" if LOGFILE is None else LOGFILE)
parser.add_argument("--log-level", default=LOGLEVEL, choices=["debug", "info", "warning", "error", "critical"], help="Logging level. [%s]" % LOGLEVEL.lower())
parser.add_argument("--pid-file", metavar="filename", default=PIDFILE, help="File to store the PID value in when daemonized. [%s]" % PIDFILE)
parser.add_argument("--address", metavar="ip-address", default=ADDRESS, help="IP address to bind to. The default binds to the wildcard for both IPv4 and IPv6. [%s]" % ADDRESS)
parser.add_argument("--port", metavar="number", default=PORT, type=int, help="TCP and UDP port number to listen on. [%d]" % PORT)
parser.add_argument("--zones", metavar="filename", default=ZONES, help="Zones JSON file. [%s]" % ZONES)
parser.add_argument("--servers", metavar="filename", default=SERVERS, help="Servers JSON file. [%s]" % SERVERS)
parser.add_argument("--geodb", metavar="filename", default=GEODB, help="GeoIP City database file to use. [%s]" % GEODB)

args = parser.parse_args()

fdns.debug = args.debug
if fdns.debug:
    args.log_level = "debug"
    args.foreground = True

logging.basicConfig(filename=args.log_file, level=getattr(logging, args.log_level.upper(), None))

if args.log_file is None and args.foreground is False:
    # Use a syslog handler for logging
    import platform, logging.handlers

    # remove existing handlers
    while len(log.root.handlers):
        log.root.removeHandler(log.root.handlers[0])

    # work out the path to the syslog socket
    path = None
    for p in ("/dev/log", "/var/run/syslog"):
        if os.path.exists(p):
            path = p
            break

    if path is None:
        raise Exception("Unable to discover path to the syslog socket")

    # create a syslog handler
    h = logging.handlers.SysLogHandler(address=path)

    if hasattr(platform, 'mac_ver'):
        # bit of a hack for macos which filters info and below by default,
        # and logging doesn't have a 'notice' level.
        h.priority_map['INFO'] = 'notice'
        if args.log_level.upper() == 'DEBUG':
            h.priority_map['DEBUG'] = 'notice'

    # add the syslog handler
    log.root.addHandler(h)


log.info("Starting DNS server on '%s' port %d" % (args.address, args.port))

if args.foreground is False:
    # discover file handles to preserve
    preserve_files = []
    for h in log.root.handlers:
        if hasattr(h, 'stream'):
            preserve_files.append(h.stream)
        if hasattr(h, 'socket'):
            preserve_files.append(h.socket)

    # create the daemon context
    ctx = daemon.DaemonContext()
    ctx.umask = 0o027
    ctx.pidfile = lockfile.pidlockfile.PIDLockFile(args.pid_file)
    ctx.preserve_files = preserve_files

    ctx.open()

try:
    # Fire it all up!
    server = fdns.Server(args.address, args.port, args.zones, args.servers, args.geodb)
    server.run()
except Exception:
    log.error("Exception when running the DNS server:\n%s" % traceback.format_exc())
